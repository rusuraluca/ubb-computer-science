#include <stdio.h>
#include <stdlib.h>
#include <time.h>
// This include pulls in everything you need to develop with OpenCL in OS X
#include <OpenCL/opencl.h>

// Include the header file generated by Xcode.  This header file contains the kernel block declaration.
#include "naive.cl.h"

// Hard-coded number of values to test, for convenience.
#define NUM_VALUES 1024
#define MAXVALUE 100
#define EPS 0.00001

// A utility function that checks that our kernel execution performs the
// requested work over the entire range of data.
static int validate(cl_float *a, cl_float *b, cl_float *output){
    int i;
    for (int i = 0; i < NUM_VALUES; ++i)
    {
        for (int j = 0; j < NUM_VALUES; ++j)
        {
            output[i + j] -= a[i] * b[j];
        }
    }
    for (i = 0; i < NUM_VALUES + NUM_VALUES + 1; i++)
    {
        // The kernel was supposed to square each value.
        if (abs(output[i]) > EPS)
        {
            fprintf(stdout,
                    "Error: Element %d did not match expected output.\n", i);
            fprintf(stdout,
                    "Saw %1.4f, expected 0\n", output[i]);
            fflush(stdout);
            return 0;
        }
    }
    return 1;
}

int main() {
    srand(time(NULL));

    // Get the OpenCL device ID for the default device on the system
    cl_device_id device_id;
    clGetDeviceIDs(NULL, CL_DEVICE_TYPE_DEFAULT, 1, &device_id, NULL);
    // Create an OpenCL context using the device
    cl_context context = clCreateContext(NULL, 1, &device_id, NULL, NULL, NULL);
    // Create a command queue for the context
    cl_command_queue queue = clCreateCommandQueue(context, device_id, 0, NULL);

    // Allocate arrays for poly and result
    float *test_a = (float *)malloc(sizeof(cl_float) * NUM_VALUES);
    float *test_b = (float *)malloc(sizeof(cl_float) * NUM_VALUES);
    float *test_out = (float *)malloc(sizeof(cl_float) * (NUM_VALUES + NUM_VALUES - 1));

    // Initialize test_a and test_b with random values
    for (int i = 0; i < NUM_VALUES; i++) {
        test_a[i] = (cl_float)(1);
        test_b[i] = (cl_float)(1);
    }

    cl_int err;

    // Create OpenCL buffer objects for test_a, test_b, and test_out
    cl_mem mem_a = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                  sizeof(cl_float) * NUM_VALUES, test_a, &err);
    if (err != CL_SUCCESS) {
        printf("Error creating buffer for a: %d\n", err);
    }
    cl_mem mem_b = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                  sizeof(cl_float) * NUM_VALUES, test_b, &err);
    if (err != CL_SUCCESS) {
        printf("Error creating buffer for b: %d\n", err);
    }
    cl_mem mem_out = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                    sizeof(cl_float) * (NUM_VALUES + NUM_VALUES - 1), test_out, &err);
    if (err != CL_SUCCESS) {
        printf("Error creating buffer for out: %d\n", err);
    }

    const char* kernel_source = poly_mult_naive;
    cl_program program = clCreateProgramWithSource(context, 1, &kernel_source, NULL, NULL);

    // Build the OpenCL program
    err = clBuildProgram(program, 1, &device_id, NULL, NULL, NULL);
    if (err != CL_SUCCESS) {
        // Handle errors in program building
        char *build_log;
        size_t log_size;
        clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
        build_log = new char[log_size+1];
        clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, log_size, build_log, NULL);
        build_log[log_size] = '\0';
        printf("Error in kernel building: \n%s\n", build_log);
        delete[] build_log;
        exit(1); // or handle the error appropriately
    }

    // Create kernel from the program
    cl_kernel kernel = clCreateKernel(program, "poly_mult_naive", &err);
    if (err != CL_SUCCESS) {
        // Handle errors in kernel creation
        printf("Error in kernel creation: %d\n", err);
        exit(1); // or handle the error appropriately
    }

    // Set kernel arguments
    clSetKernelArg(kernel, 0, sizeof(cl_mem), &mem_a);
    clSetKernelArg(kernel, 1, sizeof(cl_mem), &mem_b);
    clSetKernelArg(kernel, 2, sizeof(cl_mem), &mem_out);
    int n_values = NUM_VALUES;
    clSetKernelArg(kernel, 3, sizeof(int), &n_values);

    // Define global and local work sizes
    size_t global_size;
    size_t local_size;
    clGetKernelWorkGroupInfo(kernel, device_id, CL_KERNEL_WORK_GROUP_SIZE, sizeof(local_size), &local_size, NULL);

    // Calculate global work size
    size_t num_output_elements = NUM_VALUES + NUM_VALUES - 1;
    global_size = ((num_output_elements + local_size - 1) / local_size) * local_size;

    // Enqueue the kernel for execution
    err = clEnqueueNDRangeKernel(queue, kernel, 1, NULL, &global_size, &local_size, 0, NULL, NULL);
    if (err != CL_SUCCESS) {
        // Handle errors in kernel enqueue
        printf("Error in kernel enqueue: %d\n", err);
        exit(1); // or handle the error appropriately
    }

    // Read the results back from the device
    err = clEnqueueReadBuffer(queue, mem_out, CL_TRUE, 0, sizeof(cl_float) * (NUM_VALUES + NUM_VALUES - 1), test_out, 0, NULL, NULL);
    if (err != CL_SUCCESS) {
        // Handle errors in buffer reading
        printf("Error in buffer reading: %d\n", err);
        exit(1); // or handle the error appropriately
    }

    // Now, test_out contains the output data
    for (int i = 0; i < NUM_VALUES + NUM_VALUES - 1; ++i) {
        printf("%f ", test_out[i]);
    }
    printf("\n");

    if (validate(test_a, test_b, test_out)) {
        printf("The polynomials were properly multiplied.\n");
    }

    // Release OpenCL resources.
    clReleaseMemObject(mem_a);
    clReleaseMemObject(mem_b);
    clReleaseMemObject(mem_out);
    clReleaseKernel(kernel);
    clReleaseProgram(program);
    clReleaseCommandQueue(queue);
    clReleaseContext(context);
    free(test_a);
    free(test_b);
    free(test_out);

    return 0;
}